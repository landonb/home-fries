#!/bin/sh
# vim:tw=0:ts=2:sw=2:et:norl:ft=bash
# Project: https://github.com/landonb/sh-rm_safe#ðŸ—‘
# License: MIT

RM_SAFE_TRASH_HOME="${RM_SAFE_TRASH_HOME:-${HOME}}"

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

echo_boxy=false

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# 2016-04-26: I added rm_rotate because, while trashes were being
# created on different devices from rm_safe, rmtrash was only emptying
# the trash in the user's home.
#   Also: I find myself feeling more comfortable moving .trash to .trash-TBD
#   for a while and then deleting the .trash-TBD, just in case I don't, say,
#   in a week realize I deleted something. So here's a two-step trash:
#   if you call rmtrash once, it'll temporarily backup the .trash dirs;
#   when you call rmtrash again, it'll remove the last temporary backups.
#   In this manner, you can call rmtrash periodically, like once a month
#   or whatever, and you won't have to worry about accidentally deleting
#   things.
#   MAYBE: You could do an anacron check on the timestamp of the .trash-TBD
#          and call rm_rotate after a certain amount of time has elapsed.

rm_rotate () {
  local trash_name='.trash'
  os_is_macos && trash_name='.Trash'

  _rm_rotate_enumerate_devices () {
    if command -v findmnt > /dev/null; then
      local device_path=''
      for device_path in $( \
        findmnt -l -t fuse.gocryptfs,fuse.encfs,ext4 -o TARGET --noheadings \
          | grep -v '^/boot' \
          | sort \
      ); do
        _rm_rotate_rotate_device_trash "${device_path}"
      done
    else
      # @macOS, etc.
      _rm_rotate_rotate_device_trash "/"
    fi
  }

  _rm_rotate_rotate_device_trash () {
    local device_path="$1"

    local trash_path="${device_path}/${trash_name}"
    [ "${device_path}" = "/" ] &&
      trash_path="${RM_SAFE_TRASH_HOME}/${trash_name}"

    if [ ! -d "${trash_path}" ]; then
      echo "Skip! No trash at â€˜${trash_path}â€™"

      return 0
    fi

    local to_be_deleted="${trash_path}-TBD"

    local yes_or_no=""
    printf %s "Empty all items from trash at â€˜${trash_path}â€™? [y/n] "
    read -e yes_or_no

    # Bash-specific: [ "${yes_or_no^^}" = "Y" ]. POSIX-compatible:
    if [ "$(first_char_capped ${yes_or_no})" != 'Y' ]; then
      [ -z "${yes_or_no}" ] && echo
      echo "Skip! User said not to empty â€˜${trash_path}â€™"

      return 0
    fi

    # Remove the TBD directory from last time.
    # - Note that rm_rotate is not time-based or anything: It rotates
    #   only when user runs `rmtrash`. That is, it doesn't keep files
    #   for some set amount of time or anything; it keeps files until
    #   the user runs `rmtrash`, then it deletes the former directory
    #   and moves the active trash to the TBD position. Thus, if user
    #   wants to really permantently remove what's in the trash, they
    #   run rm_trash twice in a row.
    if [ -d "${to_be_deleted}" ]; then
      command rm -rf -- "${to_be_deleted}"
    fi

    # Avoid creating -TBD directory if trash already empty.
    if [ -n "$(command ls -- "${trash_path}")" ]; then
      # Trash not empty. Move to TBD position (will be deleted on next
      # rm_rotate), and then create a new trash directory.

      # BWARE: macOS ~/.Trash is protected, so cannot rename it.
      # - INERT: Ideally, this check would inspect ~/.Trash ACL; but
      #          it's easier to just check if macOS or not, and assume.
      if ! os_is_macos; then
        command mv -- "${trash_path}" "${to_be_deleted}"
        command touch -- "${to_be_deleted}"
        command mkdir -- "${trash_path}"
      else
        # SAVVY: Because ACL, cannot delete (or rename) ~/.Trash
        #   @macOS $ /bin/ls -led ~/.Trash
        #   drwx------+ 2 user  staff  64 May 26 13:10 /Users/user/.Trash
        #   0: group:everyone deny delete

        command mkdir -- "${to_be_deleted}"
        command chmod 700 "${to_be_deleted}"

        # BWARE: Note the mv'ing ".*" includes "." and "..", which
        # generates warnings, e.g., on Linux:
        #   $ command mv -- foo/* foo/.* bar
        #   mv: cannot move 'foo/.' to 'bar/.': Device or resource busy
        #   mv: 'foo/..' and 'bar/..' are the same file
        # Or on macOS:
        #   $ command mv -- foo/* foo/.* bar
        #   mv: rename foo/. to bar/.: Invalid argument
        #   mv: foo/.. and bar/.. are identical
        # - If we limit this script to Bash, we could use dotglob, e.g.,
        #     #!/usr/bin/env bash
        #     ...
        #     local old_dot_glob
        #     old_dot_glob="$(shopt -p dotglob)"
        #     shopt -s dotglob
        #     command mv -- "${trash_path}"/* "${to_be_deleted}"
        #     eval "${old_dot_glob}"
        # - Better yet, for POSIX compatibility, use `find`:
        find "${trash_path}" -mindepth 1 -maxdepth 1 -name "*" \
          -exec $(mv_kludge) -t "${to_be_deleted}" {} \+
      fi
    fi
  }

  _rm_rotate_enumerate_devices
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

first_char_capped () {
  printf "$1" | cut -c1-1 | tr '[:lower:]' '[:upper:]'
}

mv_kludge () {
  command -v gmv || command -v mv
}

os_is_macos () {
  [ "$(uname)" = "Darwin" ]
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

PROG_NAME="rm_rotate"

clear_traps () {
  trap - EXIT INT
}

set_traps () {
  trap -- trap_exit EXIT
  trap -- trap_int INT
}

exit_0 () {
  clear_traps

  exit 0
}

exit_1 () {
  clear_traps

  exit 1
}

trap_exit () {
  clear_traps

  # USAGE: Alert on unexpected error path, so you can add happy path.
  >&2 echo "ALERT: "$(basename -- "$0")" exited abnormally!"
  >&2 echo "- Hint: Enable \`set -x\` and run again..."

  exit 2
}

trap_int () {
  clear_traps

  exit 3
}

# ***

main () {
  set -e

  set_traps

  rm_rotate "$@"

  clear_traps
}

# Run the command unless being sourced.
if [ "$(basename -- "$(realpath -- "$0")")" = "${PROG_NAME}" ]; then
  # Being executed.
  main "$@"
else
  # Being sourced.
  export -f rm_rotate
fi

unset -f main

