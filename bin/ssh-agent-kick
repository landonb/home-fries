#!/bin/sh
# vim:tw=0:ts=2:sw=2:et:norl:ft=sh
# Author: Landon Bouma (landonb &#x40; retrosoft &#x2E; com)
# Project: https://github.com/landonb/home-fries#üçü
# License: MIT

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

source_deps () {
  # It's expected that the user sets up PATH accordingly.
  #   https://github.com/landonb/sh-colors
  #   https://github.com/landonb/sh-logger
  . "logger.sh"
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# FIXME/2020-03-27 12:11: Convert to using pass store.

_sh_ssh_agent_kick_notice_no_secrets () {
  local prev_notice=${SSH_SECRETS_NOTICE:-0}
  SSH_SECRETS_NOTICE="$(date +%s.%N)"
  if [ ${prev_notice} != "0" ]; then
    local now="$(date +%s.%N)"
    if [ "$(echo "(${now} - ${prev_notice}) < 1.0" | bc -l)" -ne 0 ] ; then
      # It's been less than 1 second since previous notice; don't repeat yourself
      # so soon.
      return
    fi
  fi

  if [ -z "${SSH_SECRETS}" ]; then
    notice 'No SSH_SECRETS directory defined.'
  else
    notice "No directory at: ${SSH_SECRETS}"
  fi
  notice '        Set this up yourself.'
  notice '        To test again: ssh-agent -k'
  notice '          and then open a new terminal.'
}

ssh_agent_kick () {
  # Note that EUID is a Bash-ism, so using `id` instead.
  # - Check nonzero ID, i.e., insist that user is not root.
  if [ $(id -u) -eq 0 ]; then
    >&2 echo "ERROR: Please try again as not root."
    return 1
  fi
  # 2020-03-18: (lb): I do not recall why checking TERM matters.
  # - Adding ERROR message, at least I'll know if/when it's called.
  if [ "${TERM}" = "dumb" ]; then
    >&2 echo "ERROR: Not an appropriate context: TERM too dumb."
    return 1
  fi
  # Pretty obvious: Lacking .ssh/, do nothing.
  if [ ! -e "${HOME}/.ssh" ]; then
    >&2 echo "ERROR: User's ~/.ssh not online; nothing to kick!"
    return 1
  fi
  # Now we made it!

  local old_level=${LOG_LEVEL}
  LOG_LEVEL=${LOG_LEVEL_NOTICE}

  # See http://help.github.com/working-with-key-passphrases/
  local sshenv="${HOME}/.ssh/environment"

  # ***

  start_agent_and_feed () {
    debug "Initializing new SSH agent... "
    /usr/bin/ssh-agent | /bin/sed 's/^echo/#echo/' > "${sshenv}"
    chmod 600 "${sshenv}"
    # Source the environ the new process spit out.
    . "${sshenv}" > /dev/null
    # Look for keys to load. Use cheat PWDs as appropriate.
    local rsa_keys="$(/bin/ls ${HOME}/.ssh/*_ed25519 ${HOME}/.ssh/*_rsa 2> /dev/null)"
    debug "rsa_keys=${rsa_keys}"
    for pvt_key in ${rsa_keys}; do
      local sent_passphrase=false
      local secret_name="$(basename -- "${pvt_key}")"
      if [ -n "${SSH_SECRETS}" ] && \
         [ -d "${SSH_SECRETS}" ] && \
         [ -e "${SSH_SECRETS}/${secret_name}" ]; \
      then
        if $(command -v expect > /dev/null); then
          debug "secret_name=${SSH_SECRETS}/${secret_name}"
          # CUTE! If $pphrase has a bracket in it, e.g., "1234[", expect complains:
          #        "missing close-bracket while executing send "1234["
          local pphrase="$(cat ${SSH_SECRETS}/${secret_name})"
          /usr/bin/expect -c " \
            spawn /usr/bin/ssh-add ${pvt_key}; \
            expect \"Enter passphrase for /home/${LOGNAME}/.ssh/${secret_name}:\"; \
            send \"${pphrase}\n\"; \
            interact ; \
          "
          unset -v pphrase
          sent_passphrase=true
        else
          notice "no expect: ignoring: ${SSH_SECRETS}/${pvt_key}"
        fi
      elif [ ! -d "${SSH_SECRETS}" ]; then
        _sh_ssh_agent_kick_notice_no_secrets
      fi
      if ! ${sent_passphrase}; then
        /usr/bin/ssh-add "${pvt_key}"
        sent_passphrase=true
      fi
      if ${sent_passphrase}; then
        # Set global variable telling caller we called ssh-add.
        # - (lb): I use to trip a one-time message on v. first logon post boot.
        # - Code that cares can `unset -v` to have variable set again on next
        #   kick; or code can set =false to disable and have kick avoid resetting.
        [ -z ${SSH_ENV_FRESH+x} ] && SSH_ENV_FRESH=true
      fi
    done
    # Test: ssh-agent -k # then, open a terminal (or call ssh_agent_kick).
  }

  ps_by_grep () {
    ps -ef | grep '\bssh-agent$'
  }

  is_running_ps () {
    ps_by_grep > /dev/null
  }

  # We could care about defunct but they do no harm, just confusion.
  #  is_defunct_ps () {
  #    ps -ef | grep '\[ssh-agent\] <defunct>$' > /dev/null
  #  }

  ps_by_pid () {
    ps --no-headers -p ${SSH_AGENT_PID}
  }

  is_running_pid () {
    [ -z "${SSH_AGENT_PID}" ] && return 1
    ps_by_pid > /dev/null
  }

  is_defunct_pid () {
    [ -z "${SSH_AGENT_PID}" ] && return 1
    ps_by_pid | grep ' <defunct>$' > /dev/null
  }

  # ***

  # Source (potentially invalid) SSH settings (if agent-created file exists).
  if [ -f "${sshenv}" ]; then
    . "${sshenv}" > /dev/null
  fi

  if is_running_ps || (is_running_pid && ! is_defunct_pid); then
    notice "agent running: use \`ssh-agent -k\` to kill"
    if ! (is_running_ps && is_running_pid); then
      warn "ssh-agent: !(ps && pid)."
      ps_by_grep
      return 1
    fi
    return 0
  fi

  start_agent_and_feed

  LOG_LEVEL=${old_level}
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

source_deps

shell_sourced () {
  for filename in "ssh-agent-kick" "ssh-kick-agent"; do
    [ "$(basename -- "$0")" = "${filename}" ] && return 1
  done
  true
}
# Note that bash_sourced only meaningful if shell_sourced is true.
bash_sourced () { declare -p FUNCNAME > /dev/null 2>&1; }

if ! shell_sourced; then
  ssh_agent_kick "${@}"
else
  bash_sourced && export -f ssh_agent_kick
  unset this_file_name
  unset -f shell_sourced
  unset -f bash_sourced
fi

